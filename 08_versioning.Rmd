# Versioning

The approach in this text makes a hard cut between the data product and doing research to improve the product.
The former should be treated as software, all best practises of software engineering apply to it.
We have looked at automation and testing in the previous chapters, now we turn to versioning and version control.
A version is a distinct snapshot of the working data product, to which a version number is assigned.

TODO explain further.

## Old Code

As you move from one version to the next, a part of the code written earlier becomes obsolete.
You might be tempted to keep this code around because it might be neede in future times.
I would advise against this.
As the project progresses the amount of unused legacy code grows, as well as the amount of used product code, because the product tends to become more sophistecated as you move on.
It will become harder to figure out what part of the code is actually used, making it more difficult to reason about the product.
Also, the package namespace starts to become clogged.
It happened more than once to me that I had created two functions with the same name when there was some old version lingering.
Happy debugging!

I think the product should only contain code that is used in the current version. 
This also implies that we should not do versioning within the code.
Wether versioned or not, you might be inclined to leave old versions of a product, such as a function to call a model or to create a report, in place.
Rather than versioning in your code, use a version control system.
Keep your codebase clean and as small as possible.
If you really want to keep your code around, and don't want to rely on version control rollbacks to retrieve old results, keep an archive folder outside the `/R` folder so it is not part of the namespace.

## Version Control

More than software engineers data scientists tend to work in solitude.
Fully using version control systems, such as *git* and *svn*, can then be considered as overkill.
In practice, they might just be used as an external backup of the code.
Write some code, push it to master, write some more code, push it to master.

<script src="https://cdnjs.cloudflare.com/ajax/libs/gitgraph.js/1.11.4/gitgraph.min.js"></script>
<canvas id="gitGraph"></canvas>
```{js}
var gitgraph = new GitGraph({
  template: "metro", // or blackarrow
  author: "",
  offsetX: 50,
  mode: "extended" // or compact if you don't want the messages
});

var master = gitgraph.branch("master");
gitgraph.commit("Initial commit"); // 1 commit upon HEAD

var develop = gitgraph.branch({name :"setup", offsetX : 200}); // New branch from HEAD
develop.commit("first queries to db");
develop.commit("splitting train and test");
develop.commit("use base rates as model");

develop.merge(master);

master.commit({message : "releasing base rate model", tag : "v1"})

var develop2 = gitgraph.branch("RS-algo1"); // New branch from HEAD

develop2.commit("data prep");
develop2.commit("trying fancy algo1");
develop2.merge(master);


var develop3 = gitgraph.branch("RS-algo2"); // New branch from HEAD
develop3.commit("data prep");
develop3.commit("trying fancy algo2");
develop3.merge(master);


var develop4 = gitgraph.branch({name :"SW-algo2", spacingX : 100}) // New branch from HEAD
develop4.commit("implementing algo2 in software");
develop4.merge(master);

master.commit({message : "releasing updated model", tag : "v2"})
```
